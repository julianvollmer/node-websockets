{
        
    "parse options": {
        "type": "feature",
        "modules": ['WebSocketBase'],
        "description": "it should be possible to pass some (network, frame) options to the base prototype",
        "steps": [
            { name: "define options schema", done: true },
            { name: "parse options schema", hint: "check how backbone does this", done: false },
            { name: "use options in the methods", done: false }
        ]
    },
        
    "listen only to url": {
        "type": "feature",
        "modules": ['WebSocketServer'],
        "description": "currently the websocket server is bound to all http upgrades but actually it should only upgraded when the url path matches",
        "steps": [
            { name: "check if this is a valid strategy", done: false },
            { name: "check how much listeners can be bound to the upgrade event", done: false },
            { name: "add some if clause to the upgrade callback which only works on right path", done: false }
        ]
    },
        
    "extension management": {
        "type": "feature",
        "modules": ['WebSocketBase', 'WebSocketClient', 'WebSocketServer', 'WebSocketUpgrade'],
        "description": "it should be able to add extensions which parse the payload after decoding and provide additional function",
        "steps": [
            { name: "add empty prototype methods (api)", done: true },
            { name: "define extension requirements", done: true, result: "{String} name, {Function} extension" },
            { name: "implement extension methods on base", done: false },
            { name: "give access to extension (names) in upgrade handlers", done: false },
            { name: "implement header syncing with extensions", done: false },
            { name: "implement extension parsing before emitting event", done: false }
        ]
    },
        
    "handle fragmented frames": {
        "type": "feature",
        "modules": ['WebSocketBase'],
        "description": "the websocket base should collect all fragmented frames and merge the payload together and emit a message event",
        "steps": [
            { name: "implement check in readFrame which looks if frame is final", done: false },
            { name: "save non final frame and it's payload to a context", done: false },
            { name: "add all non final frames to this ctx array", done: false },
            { name: "merge the ctx (payload) array together and emit it (on fin 0x00)", done: false }
        ]
    },
        
    "secured version of protocol": {
        "type": "feature",
        "modules": ['WebSocketBase', 'WebSocketFrame'],
        "description": "it should be possible to use the wss version of the protocol"
    },
    
    "finish and update documentation": {
        "type": "improvement",
        "modules": ['Documentation'],
        "description": "some parts of the docs refer to the old api, also not all modules are documented"
    },
    
    "write tests for server and client": {
        "type": "improvement",
        "modules": ['Test']
    },
    
    "update tests to use more mocha features": {
        "type": "improvement",
        "modules": ['Test'],
        "description": "maybe we can use mochas after, before, etc. and find some replace for eachFrame"
    },
    
    "add some more examples": {
        "type": "improvement",
        "modules": ['Example'],
        "description": "there should be some examples for client, base, frame"
    }
    
    "catch and error too big websocket frames": {
        "type": "bug-fix",
        "modules": ['WebSocketBase', 'WebSocketFrame'],
        "description": "the per standard defined payload maximum of two gigabytes is too much in reality catch them up"
    }

}